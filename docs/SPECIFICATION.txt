README
------

In this document I want to pretend what it should be like using this  module.

The data store will be added as a content type to a site. It will then install 
local utilities for acquiring an SQL session. 

This SQL session is going to be bound to two engines (the PII and the FIA)
This is so that the same session can commit to both engines without having
to create a separate one


DOMAINS
-------

Domains subset groups for the data store. They represent groups of schemas.

NOTE: Domains do not 'contain' schemas. They are merely markers for groups
of already existent schemas.

>>> key = Key("Early Test")
>>> domain = component.queryMultiAdapter((engine, key), IDomain)

>>> # This method seems a lot cleaner...
>>> engine.get_domain(title='Early Test')


This only gets a certain domain though...
Can we do it by name? Multi-adapter using the engine and name?

PROTOCOL
-------

A protocol takes a domain, and assigns it a timeline of accessible schema
(assigned by version as well) to ask. In a way it should control which schema
verions it is using. IT SHOULD NOT CREATE NEW SCHEMATA. Schemas should
be created from the client and then bassed to the protocol to store in
it's timeline. 

Note that protocols define the MINIMUM set of objects that should be queried
for by the system. If additional objects are added, that should be allowed.

SCHEMAS
-------

Schemata are definitions that can be instantiated and stored into the
the data store. One special property about schemas is that they can be
'versioned' this means that a schema can evolve over time and we'll still
be able to keep track of what information was stored for which schemata
version!

>>> key = Key("IDummy")
>>> version = Version("12313")
>>> schema = component.queryMultiAdapter((engine, key, version), ISchema)

>>> # This method seems a lot cleaner and straight foward
>>> schema = engine.get_schema(title="IDummy", version="123123")
>>> interface = schema.to_interface()

>>> # Possibly might work, but it's the same situation as #1
>>> schema = ISchema(ISomeInterface)

>>> # Convert to zope interface? This will not be a class adapter, but simply
>>> # method?
>>> interface = IInterface(schema)

>>> # Creating a schema
>>> schema = createObject("avrc.data.store.Schema")
>>> engine.add( schema )

>>> # Getting a schema
>>> engine.get_schema(title="IDummy")

>>> #HOW TO MANAGE?!?!!



ATTRIBUTE
---------

Attributes are also special in that they are 'independent' of the schemata. Yet,
when a schemata is specified, it must specify which attributes it uses. There
can be multiple attributes with the same name (although when the date when they
are created should be unique so as to prevent to identical attributes.

>>> key = Key("foo")
>>> attribute = component.queryMultiAdapter((engine, schema, key,) IAttribute)

>>> attribute = IAttribtue(interface['foo'])

>>> schema['foo'] = IAttribtue(interface['foo'])
>>> schema['foo'].get_type()


INSTANCE
--------

>>> instance = InstanceFactory( IGeneratedSchema )

>>> engine.put(intance) 


VOCABULARY
----------

Library for importing zope vocabularies.

I have no clue how I'm going to to this...


